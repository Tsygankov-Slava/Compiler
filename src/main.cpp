#include <iostream>
#include <string>

#include "AST/AST.h"
#include "Code/Code.h"
#include "File/File.h"
#include "FileCPP/FileCPP.h"
#include "Parser/Parser.h"

int main(int argc, char **argv) {
  if (argc == 1) {
    // Когда делаешь такие штуки и не знаешь точно, как лучше делать, советую смотреть
    // на уже готовые программы, например, тот же gcc или clang.
    //
    // Например, в Clang если ты выполнишь команду clang --help (для gcc то же самое),
    // то будет примерно следующее:
    // OVERVIEW: clang LLVM compiler
    //
    // USAGE: clang [options] file...
    //
    // OPTIONS:
    //   ...
    //
    // Советую на первых порах просто копировать это, потом ты сам поймешь как лучше
    // делать.
    // Это же касается любых таких ситуаций, например, в другом if, где у тебя
    // другая ошибка. Попробуй посмотреть, какую ошибку выведут другие
    // похожие программы и скопируй, гарантирую что так будет лучше на первых порах.
    cout << "Argument \"Path to file\" not found\n";
    // Кстати, здесь можно было бы использовать argv[0], так как там хранится
    // точное имя программы которая запускается, так твоя подсказка бужет более
    // релевантна. Например, если у меня бинарник называется ./cpm, то он был показал:
    //  ./cpm (path to file)/file.cpm
    cout << "Program launch format: \"./Compiler (path to file)/file.cpm\"";
    return 1;
  } else if (argc > 2) {
    cout << "There are a lot of arguments\n";
    cout << "Program launch format: \"./Compiler (path to file)/file.cpm\"";
    return 2;
  }

  const string path = argv[1];
  File file(path);
  file.openAndReadFile();

  Code code(path, file.getCode());
  // Кстати с помощью auto тут код можно было подсократить:
  // auto tokens = code.getTokens();
  vector<Lexeme> tokens = code.getTokens();

  Parser p(tokens);
  if (p.checkAndPrintWrong()) {
    // Советую почитать про exit codes, например вот тут:
    // https://www.geeksforgeeks.org/exit-codes-in-c-c-with-examples/
    // Вкратце, когда у тебя происходит ситуация, когда ты выводишь ошибку
    // работы программы и хочешь показать это пользователю, то следует
    // использовать значения отличные от 0, например, 1.
    // Зачем это нужно?
    // Представь что у тебя есть система (которая кстати, называется CI [Continous
    // Integration], погугли что это такое), которая после каждого изменения в репозитории
    // автоматически компилирует твой проект, чтобы проверить, что все правильно написано.
    // И для того, чтобы понять что-то пошло не так, мы можем проверить тот код с которым
    // завершил работу наш компилятор.
    // Если это будет 0, все окей.
    // А вот если не 0, то значит что-то пошло не так и нужно показать что тестирование
    // провалилось.
    //
    // И в текущем твоем варианте непонятно что есть ошибки, так как компилятор
    // завершил работу с кодом 0.
    //
    // Также конкретно здесь можно было и нужно писать return, в exit нет
    // никакого смысла. Более того, при завершении через exit не вызываются деструкторы!
    // https://www.codespeedy.com/return-vs-exit-in-main-in-cpp-with-examples/
    exit(0);
  }

  Node *head = p.getAST();
  Node *root = p.changeCommand(head);

  FileCpp fileCpp(path);
  // Из-за неправильно наименования методов у тебя получается масло масляное.
  // Достаточно было бы назвать метод generate.
  fileCpp.createFileCPP(root);
  // Я чего-то только сейчас заметил что у тебя файл то создается, но не компилируется!
  // Неудобно тестировать.
  return 0;
}
// Обычно в конце файла оставляют пустую строчку. Например, если ты посмотришь в Github, когда создаешь PR
// он, если у файла нет в конце пустой строки, показывает красный значок. Лучше ее тут оставлять, но это мелочи
// для общего развития.
